<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nova AI | Neural Interface</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .chat-glow { 
            box-shadow: 0 0 20px rgba(168, 85, 247, 0.3); 
        }
        .recording { 
            animation: pulse 1.5s infinite; 
            background-color: #ef4444 !important; 
            border-color: #f87171 !important; 
        }
        @keyframes pulse { 
            0% { transform: scale(1); } 
            50% { transform: scale(1.1); opacity: 0.8; } 
            100% { transform: scale(1); } 
        }
        .custom-scrollbar::-webkit-scrollbar { 
            width: 4px; 
        }
        .custom-scrollbar::-webkit-scrollbar-thumb { 
            background: #334155; 
            border-radius: 10px; 
        }
        .memory-tag { 
            animation: slideIn 0.4s ease-out; 
        }
        @keyframes slideIn { 
            from { transform: translateX(-20px); opacity: 0; } 
            to { transform: translateX(0); opacity: 1; } 
        }
        @keyframes slideInBottom {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .animate-in {
            animation: slideInBottom 0.3s ease-out;
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-100 flex h-screen font-sans overflow-hidden">

    <!-- Sidebar: Thought Log -->
    <aside class="w-80 border-r border-purple-900/30 bg-slate-900/50 flex flex-col hidden md:flex">
        <div class="p-4 border-b border-purple-900/30 bg-slate-900">
            <h2 class="text-xs font-bold uppercase tracking-widest text-purple-400">System Thought Log</h2>
        </div>
        <div id="thought-log" class="flex-1 overflow-y-auto p-4 space-y-2 text-[10px] font-mono text-slate-500 custom-scrollbar">
            <div>[SYSTEM]: Nova Core Initialized...</div>
        </div>
    </aside>

    <!-- Main Chat Section -->
    <section class="flex-1 flex flex-col relative">
        <!-- Header -->
        <header class="p-4 flex justify-between items-center border-b border-purple-900/30 bg-slate-950/80 backdrop-blur-md z-10">
            <div>
                <h1 class="text-xl font-black bg-gradient-to-r from-purple-400 to-pink-500 bg-clip-text text-transparent">NOVA AI</h1>
                <div class="flex items-center gap-2">
                    <span id="status-indicator" class="h-2 w-2 rounded-full bg-green-500 animate-pulse"></span>
                    <span id="status-text" class="text-[10px] text-slate-400 uppercase tracking-tighter">Neural Core: Active</span>
                </div>
            </div>
            <button onclick="location.reload()" class="text-slate-500 hover:text-white transition-colors" title="Refresh">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            </button>
        </header>

        <!-- Chat Messages -->
        <main id="chat-box" class="flex-1 overflow-y-auto p-6 space-y-6 custom-scrollbar pb-32">
            <div class="flex flex-col items-start">
                <div class="bg-purple-900/10 border border-purple-500/20 p-4 rounded-2xl rounded-tl-none max-w-[85%] text-slate-300">
                    Hello! I'm Nova. Connection established. How can I assist you today?
                </div>
            </div>
        </main>

        <!-- Input Footer -->
        <footer class="absolute bottom-0 w-full p-6 bg-gradient-to-t from-slate-950 via-slate-950 to-transparent">
            <div class="max-w-4xl mx-auto relative group">
                <div class="relative flex items-center gap-3 bg-slate-900 border border-purple-900/50 rounded-full p-2 pr-4 shadow-2xl">
                    <button id="record-btn" class="h-12 w-12 flex items-center justify-center bg-purple-600 rounded-full hover:bg-purple-500 transition-all text-white active:scale-90" title="Hold to record">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                        </svg>
                    </button>
                    <input type="text" id="text-input" placeholder="Type or speak to Nova..." class="flex-1 bg-transparent border-none focus:ring-0 text-white placeholder-slate-500 px-2 text-sm" />
                    <button id="send-btn" class="text-purple-400 hover:text-pink-400 transition-colors" title="Send message">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" />
                        </svg>
                    </button>
                </div>
            </div>
        </footer>
    </section>

    <script>
        // Configuration - Change this port if you're using 8002 instead of 8001
        const PORT = 8001; 
        const API_BASE = `http://127.0.0.1:${PORT}`;
        
        // DOM Elements
        const chatBox = document.getElementById('chat-box');
        const textInput = document.getElementById('text-input');
        const sendBtn = document.getElementById('send-btn');
        const recordBtn = document.getElementById('record-btn');
        const thoughtLog = document.getElementById('thought-log');
        const statusIndicator = document.getElementById('status-indicator');
        const statusText = document.getElementById('status-text');
        
        // State
        let mediaRecorder; 
        let audioChunks = []; 
        let conversationHistory = [];

        // Helper Functions
        function log(msg, type = "info") {
            const time = new Date().toLocaleTimeString([], { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            
            const colorMap = {
                "memory": "text-pink-400",
                "error": "text-red-400",
                "success": "text-green-400",
                "info": "text-slate-500"
            };
            
            const color = colorMap[type] || colorMap.info;
            thoughtLog.innerHTML += `<div class="${color}">[${time}] ${msg}</div>`;
            thoughtLog.scrollTop = thoughtLog.scrollHeight;
        }

        function setStatus(status, text) {
            const statusMap = {
                "active": { color: "bg-green-500", text: "Neural Core: Active" },
                "thinking": { color: "bg-yellow-500", text: "Neural Core: Thinking..." },
                "error": { color: "bg-red-500", text: "Neural Core: Error" },
                "listening": { color: "bg-blue-500", text: "Neural Core: Listening..." }
            };
            
            const config = statusMap[status] || statusMap.active;
            statusIndicator.className = `h-2 w-2 rounded-full ${config.color} animate-pulse`;
            statusText.textContent = text || config.text;
        }

        function addMessage(role, text) {
            const isUser = role === 'user';
            const wrapper = document.createElement('div');
            wrapper.className = `flex flex-col ${isUser ? 'items-end' : 'items-start'} animate-in`;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `${
                isUser 
                    ? 'bg-purple-600 text-white shadow-lg' 
                    : 'bg-slate-900 border border-purple-900/30 text-slate-200'
            } p-4 rounded-2xl ${
                isUser ? 'rounded-tr-none' : 'rounded-tl-none'
            } max-w-[85%] text-sm leading-relaxed`;
            messageDiv.textContent = text;
            
            wrapper.appendChild(messageDiv);
            chatBox.appendChild(wrapper); 
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function showMemoryVisual(category, text, score) {
            const colors = { 
                personal_details: 'bg-blue-500/20 border-blue-500/50 text-blue-400', 
                user_preferences: 'bg-green-500/20 border-green-500/50 text-green-400', 
                projects: 'bg-orange-500/20 border-orange-500/50 text-orange-400', 
                routines: 'bg-purple-500/20 border-purple-500/50 text-purple-400', 
                meta: 'bg-cyan-500/20 border-cyan-500/50 text-cyan-400', 
                general: 'bg-slate-500/20 border-slate-500/50 text-slate-400' 
            };
            
            const colorClass = colors[category] || colors.general;
            const memDiv = document.createElement('div');
            memDiv.className = `memory-tag flex flex-col gap-1 ${colorClass} p-3 rounded-xl border text-[11px] max-w-[90%] shadow-lg mb-2`;
            
            const categoryName = category.replace(/_/g, ' ').toUpperCase();
            const scorePercent = Math.round(score * 100);
            
            memDiv.innerHTML = `
                <div class="flex justify-between items-center border-b border-current/20 pb-1 mb-1 font-bold">
                    <span>ðŸ§  ${categoryName}</span>
                    <span>${scorePercent}%</span>
                </div>
                <div class="italic">"${text}"</div>
            `;
            
            chatBox.appendChild(memDiv); 
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        async function performChat(input) {
            if (!input.trim()) return;
            
            addMessage('user', input);
            conversationHistory.push({ role: "user", content: input });
            log(`USER: "${input}"`);
            setStatus('thinking');

            try {
                log("SENT TO BRAIN: Waiting for response...");
                
                const response = await fetch(`${API_BASE}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        messages: conversationHistory, 
                        user_id: 1 
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                let replyText = data.content || "";

                // Extract and display memory tags
                const memoryMatch = replyText.match(/\{[^}]*"text"[^}]*\}/g);
                if (memoryMatch) {
                    memoryMatch.forEach(jsonStr => {
                        try {
                            const memData = JSON.parse(jsonStr);
                            const cat = memData.categories?.[0] || 'general';
                            const memText = memData.text || memData.memory_text || '';
                            const score = memData.score || 1.0;
                            
                            if (memText) {
                                showMemoryVisual(cat, memText, score);
                                log(`MEMORY RETRIEVED [${cat}] "${memText}"`, "memory");
                            }
                            
                            replyText = replyText.replace(jsonStr, "");
                        } catch(e) {
                            log(`Failed to parse memory: ${e.message}`, "error");
                        }
                    });
                }

                const cleanReply = replyText.trim();
                addMessage('assistant', cleanReply);
                conversationHistory.push({ role: "assistant", content: cleanReply });
                log(`NOVA: "${cleanReply.substring(0, 50)}..."`, "success");
                setStatus('active');
                
                // Trigger TTS
                try {
                    await fetch(`${API_BASE}/speak`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ text: cleanReply }) 
                    });
                } catch(e) {
                    log(`TTS Error: ${e.message}`, "error");
                }
                
            } catch (err) {
                log(`ERROR: ${err.message}`, "error");
                addMessage('assistant', "âš ï¸ Neural glitch detected. Please check that the server is running and try again.");
                setStatus('error');
            }
        }

        // Event Handlers
        sendBtn.onclick = () => { 
            const val = textInput.value; 
            if (val) { 
                performChat(val); 
                textInput.value = ''; 
            } 
        };
        
        textInput.onkeydown = (e) => { 
            if (e.key === 'Enter') {
                sendBtn.click();
            }
        };

        // Voice Recording
        recordBtn.onmousedown = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream); 
                audioChunks = [];
                
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                
                mediaRecorder.onstop = async () => {
                    recordBtn.classList.remove('recording');
                    setStatus('active');
                    
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    const formData = new FormData(); 
                    formData.append('file', audioBlob, 'recording.wav');
                    
                    log("STT: Processing voice...");
                    
                    try {
                        const res = await fetch(`${API_BASE}/stt`, { 
                            method: 'POST', 
                            body: formData 
                        });
                        
                        const d = await res.json(); 
                        
                        if (d.text) {
                            log(`STT: Transcribed: "${d.text}"`, "success");
                            performChat(d.text);
                        } else if (d.error) {
                            log(`STT Error: ${d.error}`, "error");
                        }
                    } catch(e) {
                        log(`STT Request Failed: ${e.message}`, "error");
                    }
                };
                
                mediaRecorder.start(); 
                recordBtn.classList.add('recording'); 
                setStatus('listening');
                log("MIC: Listening...");
                
            } catch (err) { 
                log(`Mic Error: ${err.message}`, "error");
                alert("Microphone access denied. Please grant permission and try again."); 
            }
        };
        
        recordBtn.onmouseup = () => { 
            if (mediaRecorder?.state === "recording") {
                mediaRecorder.stop();
                log("MIC: Stopped");
            }
        };

        // Initialize - Check server connection
        (async function checkConnection() {
            try {
                const response = await fetch(`${API_BASE}/health`);
                const data = await response.json();
                
                if (data.status === 'healthy') {
                    log(`Connected to ${data.service}`, "success");
                    log(`Model: ${data.model}`, "success");
                    setStatus('active');
                } else {
                    throw new Error('Unhealthy server response');
                }
            } catch(e) {
                log(`Server connection failed: ${e.message}`, "error");
                log(`Make sure server is running on port ${PORT}`, "error");
                setStatus('error', 'Server Offline');
            }
        })();
    </script>
</body>
</html>